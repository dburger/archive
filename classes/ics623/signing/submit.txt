Hello Dr. Peterson, here is my signature algorithm assignment.  You will find
the output that my two programs produced followed by the source code.  For the
El Gamal signature, I called my program egds.  For the Digital Signature
Algorithm, I called my program dsa.  I included two makefiles because I don't
know how to produce two executables from just one makefile.

thanks,
djb


________________________________________________________________________________
Output of running ./egds
________________________________________________________________________________
uhunix2:/home/23/dburger/classes/ics623/signing% ./egds
=========================================================
Verifying Dr. Peterson's results:

Public key y is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x4060ee72, 0x0cf043b8, 0x1eef6e0a, 0x284f8cda,
0xc95f5d5d, 0x520667d1, 0x456495f3, 0x9b181b8a,
0x704b8727, 0x1b567c21, 0xbfcca20a, 0x7adeefae,
0xf9f5551a, 0x65f04c32, 0x89444ff5, 0x543d851f

k':
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x11da4671, 0xca3e1ec5, 0xe056449f, 0x50b23ded,
0x05eb23a2, 0x8a3305b9, 0x590a4273, 0xf17b641f,
0x59036f1a, 0xa4f2a5fb, 0x566412be, 0xe54d1e46,
0x81fe945c, 0xfcabd2b6, 0xb41b8582, 0x924791eb

r is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x4fb4756f, 0xfae2a107, 0x6472482b, 0x7504ffaf,
0x25f2e29b, 0xe1c34896, 0x268ea268, 0xdca0e397,
0x9485854c, 0x46800164, 0x5355b7ca, 0x2bd6d043,
0x102c1d8a, 0x5fb62e53, 0x374a4c99, 0x60fce126

s is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x0b311901, 0x8db5d93a, 0xddd0e461, 0x8bab7373,
0x38f6d540, 0xbb0616df, 0x78efd684, 0x66498580,
0x9d5a8ef8, 0x953d0fb5, 0x518f8d01, 0x8c4a597e,
0xcccd1599, 0x8f7fa137, 0xc4316862, 0x780ba6f3

res1:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x43b374ba, 0x9296e148, 0x135788f8, 0x7ff53641,
0xee25a3e5, 0x853d1632, 0x072ee516, 0xe475dcb7,
0x95359497, 0xb4408c2f, 0xf34584a0, 0xa90e5922,
0xa8b59ad8, 0x08b36e98, 0x926e1348, 0xa8be7e4a

res2:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x43b374ba, 0x9296e148, 0x135788f8, 0x7ff53641,
0xee25a3e5, 0x853d1632, 0x072ee516, 0xe475dcb7,
0x95359497, 0xb4408c2f, 0xf34584a0, 0xa90e5922,
0xa8b59ad8, 0x08b36e98, 0x926e1348, 0xa8be7e4a

Signature verifies!
=========================================================
Now working on some text of my own, I will sign the hash.

SHA1 hash of text:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x10c59d4b,
0x4508046d, 0x8e36bcff, 0x949a879a, 0xd359ece5

Determining if chosen myk is relatively prime to p - 1...
myk is relatively prime to p - 1!

Public key y is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x4060ee72, 0x0cf043b8, 0x1eef6e0a, 0x284f8cda,
0xc95f5d5d, 0x520667d1, 0x456495f3, 0x9b181b8a,
0x704b8727, 0x1b567c21, 0xbfcca20a, 0x7adeefae,
0xf9f5551a, 0x65f04c32, 0x89444ff5, 0x543d851f

r is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x420d45d9, 0x91322609, 0x8aeb4486, 0x375b0e20,
0x7ee315c6, 0xc43ec584, 0x9c43645a, 0x666835df,
0xe5ab9714, 0x6b321712, 0xeb75cdf9, 0xa785ae7a,
0x76bc59f3, 0xc1554da0, 0xf4210467, 0x958c4ae1

s is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x2ed3fbb6, 0x64ab40f7, 0x500aa299, 0xb506db35,
0x23bab063, 0xb8f6f254, 0x9bbfb7f0, 0xaeee8f9f,
0xb99ed75e, 0xb6f2d9cd, 0x4bf520e2, 0x5ea5f2ef,
0x15c49929, 0xec64886a, 0xdbf31cc7, 0x156c63c1

res1:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x311c4b82, 0xb63fee4b, 0x11586a44, 0xb0a4159f,
0x47f107c0, 0xed919a15, 0x8ead5649, 0x51a65d6b,
0xe8493b4b, 0x982d09be, 0x78b23e9d, 0xa7d30f3e,
0x79d5e27a, 0xb3c39d2f, 0x23f3b23f, 0xf66eaea1

res2:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x311c4b82, 0xb63fee4b, 0x11586a44, 0xb0a4159f,
0x47f107c0, 0xed919a15, 0x8ead5649, 0x51a65d6b,
0xe8493b4b, 0x982d09be, 0x78b23e9d, 0xa7d30f3e,
0x79d5e27a, 0xb3c39d2f, 0x23f3b23f, 0xf66eaea1

Signature verifies!
________________________________________________________________________________
Output of running ./dsa
________________________________________________________________________________
=========================================================
Verifying Dr. Peterson's results:

Public key y is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x41000a3b, 0x3ba69725, 0x0197a45f, 0xe725eed0,
0xef029c3d, 0x311ff43a, 0x17784bf8, 0xf4579907,
0x7a5e6b69, 0x07815d6f, 0xf523872a, 0x7010d9bd,
0xd3ae7a98, 0x48a9454e, 0x35dcf912, 0x1675e01f

r is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x1bec1190,
0x79a8d585, 0x253c4619, 0x5d2f899d, 0x90e38252

k' is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x7d5f5e08,
0xb46f64ec, 0xd41bce75, 0x31795a1b, 0x93efd4dc

s is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0xde036098,
0x1985789e, 0x2d65ec68, 0x4bce4c61, 0xaf662aaa

w is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x532e26ee,
0x10b60a7a, 0x79a6280e, 0x19ff7b4b, 0x5b3515ef

u1 is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0xd0ac4ced,
0xf2a667bb, 0x8605165f, 0xd85d71e9, 0xedf2b15e

u2 is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x8aabf1bb,
0x8b1ecd3e, 0x0c894756, 0x4163ee60, 0x82286bf1

v is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x1bec1190,
0x79a8d585, 0x253c4619, 0x5d2f899d, 0x90e38252

v==r, Signature verifies!
=========================================================

Now working on some text of my own, I will sign the hash.

Hash that we will sign:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0xcf2cf490,
0xeb34464c, 0x73d0b0fa, 0x06ab3914, 0xd8153e17

Determining if chosen myk is relatively prime to q...
myk is relatively prime to q!

Public key y is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x41000a3b, 0x3ba69725, 0x0197a45f, 0xe725eed0,
0xef029c3d, 0x311ff43a, 0x17784bf8, 0xf4579907,
0x7a5e6b69, 0x07815d6f, 0xf523872a, 0x7010d9bd,
0xd3ae7a98, 0x48a9454e, 0x35dcf912, 0x1675e01f

r is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x7b0adff1,
0x4ad16abb, 0x196bc25c, 0x020f4f26, 0x87f1c914

s is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0xe3c83c99,
0x43713106, 0xb0518f36, 0x5eab2e41, 0xf189bb78

w is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x5fafeee1,
0x7e0bd676, 0x97d3e6a0, 0x107a05ef, 0xd8589fbf

u1 is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0xb220066f,
0x36ece86a, 0x916cf008, 0xf626f5c9, 0x63fbeea3

u2 is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x577d9160,
0x52a4f842, 0xb456a12b, 0x81e16739, 0x290e0908

v is:
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x00000000,
0x00000000, 0x00000000, 0x00000000, 0x7b0adff1,
0x4ad16abb, 0x196bc25c, 0x020f4f26, 0x87f1c914

v==r, Signature verifies!

________________________________________________________________________________
makefile for egds:
________________________________________________________________________________
egds: egds.o long.o sha1.o
	gcc egds.o long.o sha1.o -o egds
egds.o: egds.c long.h
	gcc egds.c -c
long.o: long.c long.h
	gcc long.c -c
sha1.o: sha1.c
	gcc sha1.c -c

________________________________________________________________________________
main program file for egds, egds.c:
________________________________________________________________________________

/*=============================================================================
Assignment: El Gamal digital signatures
Author:     David J. Burger
Language:   ANSI C running on UHUNIX2 (Solaris)

Class:      ICS 623
Instructor: Dr. Peterson
Due Date:   12/02/01
===============================================================================
File:         egds.c

Description:  this file contains the main entry point for a proram that
              demonstrates El Gamal digital signatures.  It can be compiled
              by running make with the included makefile.  It is executed by
              typing ./egds
=============================================================================*/

#include <stdio.h>

#include "long.h"
#include "sha1.h"

  UL p[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x76ba9c0d, 0xd6af4e18, 0x8bcce75b, 0xcb7a0ce9,
    0xb6c3128d, 0x2b4c21cc, 0x2adb4821, 0xba53ea2a,
    0x1b181203, 0x42bfbfad, 0x89bee4d5, 0xeb9b0544,
    0xceec5cef, 0xee03b004, 0xb410ee20, 0xe48928ab
  };

  UL q[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0xef049282,
    0xe49accee, 0xe5675b4a, 0x7fde735a, 0x9df5f9bb
  };

  UL f[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x3f951178, 0x18a9fade, 0x0a023be4,
    0xcc97ebec, 0x1dd9e632, 0x6e7a4738, 0x3a0e053e,
    0x8d4725f8, 0x724eb4e8, 0xf2f7eaa6, 0xe946012f
  };

  UL g[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000002
  };

  UL x[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x74c0e013, 0xbfb6842a, 0x679f43ba, 0x09179d7c,
    0xed643c8c, 0x4fc38516, 0xad569042, 0x0e1935f6,
    0x9925b0b4, 0x797447f8, 0xc1212912, 0x680fbfcc,
    0xe1f91f72, 0xaa7fe944, 0xb3abc6ce, 0x32895a88
  };

  UL h[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x2615c94b,
    0x736a7aa1, 0x6faea1d2, 0xf17b72fb, 0x1f9873dd
  };

  UL k[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x03cd3747, 0x06d7d4b3, 0x046cdbe2, 0x6a5d128c,
    0x427c3c55, 0x31169898, 0x77a4044d, 0x56f32f43,
    0x56e509fe, 0x06058ed8, 0x1c06dac8, 0x4431b782,
    0x3ab50c2a, 0x60b7acd9, 0x10d63af1, 0x000041a7
  };

  UL myk[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x02EA3892, 0x7BD2E392, 0x083ECA91, 0xFE392AF0,
    0xDA95BC39, 0x2EBA9561, 0xAAE8CD37, 0x3E8BCDA9,
    0x087BE63C, 0x1E9BCAE9, 0x35EA2393, 0x38EFC712,
    0xA97EF22E, 0xD974EFAB, 0x39BEACDA, 0x38EAC983
  };

  char stuff[] = "This is the stuff I would like to sign.  Well, actually I \
    am not going to sign this text but a hash of this text.  That is what is \
    usually done so that the computation can be done much faster.  I guess \
    that is about all I have to say, so this will be the end of my jabber.";

/*=============================================================================
Function fprintUL

Purpose:  prints the hex value of an array of size unsigned longs
          
Parameters:
          *p - array containing the unsigned longs
          size - number of unsigned longs to print from the array
          
Returns:  nothing, outputs hex values of the unsigned longs on the screen
=============================================================================*/
void fprintUL(FILE *fp, UL *p, int size) {
  int i;
  for (i=0;i<size;i++) {
    fprintf(fp,"0x%08x",p[i]);
    if ((i+1)%size==0)
      fprintf(fp,"\n");
    else if ((i+1)%4==0)
      fprintf(fp,",\n");
    else
      fprintf(fp,", ");
  }
  fprintf(fp,"\n");
}

/*=============================================================================
Function main

Purpose:  main entry point of program.  Demonstrates El Gamal by verifying the
          results demonstrated by Dr. Peterson and then uses El Gamal to sign
          and verify a document of my own.
          
Parameters:
     not used
               
Returns:  nothing, performs El Gamal digital signatures
=============================================================================*/
int main(int argc, char *argv[]) {

  UL y[32], r[32], qminus1[32], fminus1[32], pminus1[32], temp1[32], temp2[32],
    one[32], kprime[32], s[32], hcopy[32], res1[32], res2[32], mykprime[32];

  UL hash[32], hashcopy[32];
  struct hash *texthash;

  printf("=========================================================\n");
  printf("Verifying Dr. Peterson's results:\n\n");

  mexp(g,x,y,p); /* here we compute public key y */

  printf("Public key y is:\n");
  fprintUL(stdout,y,32);

  /* now finding kprime */
  zeroUL(one,32);
  one[31] = 1;

  copyUL(q,qminus1,32);
  copyUL(f,fminus1,32);
  copyUL(p,pminus1,32);
  msub(qminus1,one,p);
  msub(fminus1,one,p);
  msub(pminus1,one,p);

  mmult(qminus1,fminus1,temp1,p);

  msub(temp1,one,p);

  mexp(k,temp1,kprime,pminus1);

  printf("k':\n");
  fprintUL(stdout,kprime,32);

  mexp(g,k,r,p); /* and now determine r */

  printf("r is:\n");
  fprintUL(stdout,r,32);

  /* and now we find s */
  mmult(x,r,temp1,pminus1);

  copyUL(h,hcopy,32);

  msub(hcopy,temp1,pminus1);

  mmult(kprime,hcopy,s,pminus1);

  printf("s is:\n");
  fprintUL(stdout,s,32);

  /* now for verification */
  mexp(y,r,temp1,p);
  mexp(r,s,temp2,p);

  mmult(temp1,temp2,res1,p);

  printf("res1:\n");
  fprintUL(stdout,res1,32);

  mexp(g,h,res2,p);

  printf("res2:\n");
  fprintUL(stdout,res2,32);

  if (mcmp(res1,res2)==0)
    printf("Signature verifies!\n");
  else
    printf("Signature does not verify!\n");
  printf("=========================================================\n");

  printf("Now working on some text of my own, I will sign the hash.\n\n");

  texthash = (struct hash *)malloc(sizeof(struct hash));
  sha1Mem(stuff,strlen(stuff),texthash);

  zeroUL(hash,32);
  hash[31] = texthash->H4;
  hash[30] = texthash->H3;
  hash[29] = texthash->H2;
  hash[28] = texthash->H1;
  hash[27] = texthash->H0;

  printf("SHA1 hash of text:\n");
  fprintUL(stdout,hash,32);

  printf("Determining if chosen myk is relatively prime to p - 1...\n");
  mmult(qminus1,fminus1,temp1,pminus1);

  mexp(myk,temp1,temp2,pminus1);

  if (mcmp(temp2,one)==0)
    printf("myk is relatively prime to p - 1!\n\n");
  else {
    printf("Chosen myk is not relatively prime to p - 1, please \
            choose another myk.\n");
    exit(0);
  }

  printf("Public key y is:\n");
  fprintUL(stdout,y,32);

  /* determine mykprime */

  mmult(qminus1,fminus1,temp1,p);

  msub(temp1,one,p);

  mexp(myk,temp1,mykprime,pminus1);

  mexp(g,myk,r,p); /* and now determine r */

  printf("r is:\n");
  fprintUL(stdout,r,32);

  /* find the s for this message */
  mmult(x,r,temp1,pminus1);

  copyUL(hash,hashcopy,32);

  msub(hashcopy,temp1,pminus1);

  mmult(mykprime,hashcopy,s,pminus1);

  printf("s is:\n");
  fprintUL(stdout,s,32);

  /* now for verification */
  mexp(y,r,temp1,p);
  mexp(r,s,temp2,p);

  mmult(temp1,temp2,res1,p);

  printf("res1:\n");
  fprintUL(stdout,res1,32);

  mexp(g,hash,res2,p);

  printf("res2:\n");
  fprintUL(stdout,res2,32);

  if (mcmp(res1,res2)==0)
    printf("Signature verifies!\n");
  else
    printf("Signature does not verify!\n");

}
________________________________________________________________________________
makefile for dsa:
________________________________________________________________________________
dsa: dsa.o long.o sha1.o
	gcc dsa.o long.o sha1.o -o dsa
dsa.o: dsa.c long.h
	gcc dsa.c -c
long.o: long.c long.h
	gcc long.c -c
sha1.o: sha1.c
	gcc sha1.c -c

________________________________________________________________________________
main program for dsa, dsa.c:
________________________________________________________________________________

/*=============================================================================
Assignment: DSA
Author:     David J. Burger
Language:   ANSI C running on UHUNIX2 (Solaris)

Class:      ICS 623
Instructor: Dr. Peterson
Due Date:   12/02/01
===============================================================================
File:         dsa.c

Description:  this file contains the main entry point for a proram that
              demonstrates DSA.  It can be compiled
              by running make with the included makefile.  It is executed by
              typing ./dsa
=============================================================================*/

#include <stdio.h>

#include "long.h"
#include "sha1.h"

  UL p[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x76ba9c0d, 0xd6af4e18, 0x8bcce75b, 0xcb7a0ce9,
    0xb6c3128d, 0x2b4c21cc, 0x2adb4821, 0xba53ea2a,
    0x1b181203, 0x42bfbfad, 0x89bee4d5, 0xeb9b0544,
    0xceec5cef, 0xee03b004, 0xb410ee20, 0xe48928ab
  };

  UL q[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0xef049282,
    0xe49accee, 0xe5675b4a, 0x7fde735a, 0x9df5f9bb
  };

  UL f[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x3f951178, 0x18a9fade, 0x0a023be4,
    0xcc97ebec, 0x1dd9e632, 0x6e7a4738, 0x3a0e053e,
    0x8d4725f8, 0x724eb4e8, 0xf2f7eaa6, 0xe946012f
  };

  UL g[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x689b967d, 0xacf08055, 0x69698747, 0x29c6fe28,
    0x817ea51d, 0x6262070d, 0x6788431c, 0x0d3a1cf9,
    0xaf67c036, 0xab46bf2d, 0xc18782d1, 0x8eeea38f,
    0x950a2d17, 0x32ad274f, 0xaacf9708, 0x259b9912
  };

  UL x[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x2e7b63f6,
    0x8866d06c, 0xe7924f61, 0x675ac266, 0xccb6f684
  };

  UL h[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x2615c94b,
    0x736a7aa1, 0x6faea1d2, 0xf17b72fb, 0x1f9873dd
  };

  UL k[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x4431b782,
    0x3ab50c2a, 0x60b7acd9, 0x10d63af1, 0x000041a7
  };

  UL myk[] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0xE246EC75,
    0x7BC2AEF4, 0xFD73BA34, 0x2009ACBD, 0x10FA58F6
  };

  char stuff[] = "Here is a lot of text to sign...well, once again I will \
    be signing a hash of this text.  Signing a hash is the way it works with \
    DSA.  The hash algorithm used is the sha1 standard.  I will be using the \
    hash routine that I wrote to has a char array.  It seems to work quite \
    well.";

/*=============================================================================
Function fprintUL

Purpose:  prints the hex value of an array of size unsigned longs
          
Parameters:
          *p - array containing the unsigned longs
          size - number of unsigned longs to print from the array
          
Returns:  nothing, outputs hex values of the unsigned longs on the screen
=============================================================================*/
void fprintUL(FILE *fp, UL *p, int size) {
  int i;
  for (i=0;i<size;i++) {
    fprintf(fp,"0x%08x",p[i]);
    if ((i+1)%size==0)
      fprintf(fp,"\n");
    else if ((i+1)%4==0)
      fprintf(fp,",\n");
    else
      fprintf(fp,", ");
  }
  fprintf(fp,"\n");
}

/*=============================================================================
Function main

Purpose:  this is the main entry point of the program.  It verifies the DSA
          computations that Dr. Peterson showed us and then I use DSA on some
          text of my own.
          
Parameters:
          not used
          
Returns:  nothing, DSA is demonstrated
=============================================================================*/
int main(int argc, char *argv[]) {

  UL y[32], r[32], qminus1[32], fminus1[32], pminus1[32], temp1[32], temp2[32],
    one[32], kprime[32], s[32], hcopy[32], res1[32], res2[32], w[32], u1[32],
    u2[32], v[32], mykprime[32];

  UL hash[32], hashcopy[32];
  struct hash *texthash;

  /* make a one to work with */
  zeroUL(one,32);
  one[31] = 1;

  /* first demonstrate that Dr. Peterson's example works as shown */

  printf("=========================================================\n");
  printf("Verifying Dr. Peterson's results:\n\n");

  mexp(g,x,y,p); /* here we compute public key y */

  printf("Public key y is:\n");
  fprintUL(stdout,y,32);

  /* and now determine r */
  mexp(g,k,r,p);
  mmult(one,r,r,q);

  printf("r is:\n");
  fprintUL(stdout,r,32);

  /* now calculate kprime */
  copyUL(q,qminus1,32);
  copyUL(f,fminus1,32);
  copyUL(p,pminus1,32);
  msub(qminus1,one,p);
  msub(fminus1,one,p);
  msub(pminus1,one,p);

  mmult(qminus1,fminus1,temp1,p);

  msub(temp1,one,p);

  mexp(k,temp1,kprime,q);

  printf("k' is:\n");
  fprintUL(stdout,kprime,32);

  /* now we get the s */
  mmult(x,r,temp1,q);
  madd(temp1,h,q);

  mmult(kprime,temp1,s,q);

  printf("s is:\n");
  fprintUL(stdout,s,32);

  /* calculate w=sprime */
  mmult(qminus1,fminus1,temp1,p);
  msub(temp1,one,p);
  
  mexp(s,temp1,w,q);

  printf("w is:\n");
  fprintUL(stdout,w,32);

  /* calculate u1 */
  mmult(h,w,u1,q);

  printf("u1 is:\n");
  fprintUL(stdout,u1,32);

  /* calculate u2 */
  mmult(r,w,u2,q);

  printf("u2 is:\n");
  fprintUL(stdout,u2,32);

  /* now calculate v */
  mexp(g,u1,temp1,p);
  mexp(y,u2,temp2,p);
  mmult(temp1,temp2,temp1,p);

  mmult(one,temp1,v,q);
                     
  printf("v is:\n");
  fprintUL(stdout,v,32);

  if (mcmp(r,v)==0)
    printf("v==r, Signature verifies!\n");
  else
    printf("v!=r, Signature does not verify!\n");
  printf("=========================================================\n\n");

  printf("Now working on some text of my own, I will sign the hash.\n\n");

  /* first get the hash we are going to sign */
  texthash = (struct hash *)malloc(sizeof(struct hash));

  sha1Mem(stuff,strlen(stuff),texthash);

  zeroUL(hash,32);
  hash[31] = texthash->H4;
  hash[30] = texthash->H3;
  hash[29] = texthash->H2;
  hash[28] = texthash->H1;
  hash[27] = texthash->H0;

  printf("Hash that we will sign:\n");
  fprintUL(stdout,hash,32);

  printf("Determining if chosen myk is relatively prime to q...\n");
  
  mexp(myk,qminus1,temp1,q);

  if (mcmp(temp1,one)==0)
    printf("myk is relatively prime to q!\n\n");
  else {
    printf("Chosen myk is not relatively prime to q, please \
            choose another myk.\n");
    exit(0);
  }

  mexp(g,x,y,p); /* here we compute public key y */

  printf("Public key y is:\n");
  fprintUL(stdout,y,32);

  /* and now determine r */
  mexp(g,myk,r,p);
  mmult(one,r,r,q);

  printf("r is:\n");
  fprintUL(stdout,r,32);

  /* calculate mykprime */
  copyUL(qminus1,temp1,32);
  msub(temp1,one,q);
  mexp(myk,temp1,mykprime,q);

  /* calculate s */
  mmult(x,r,temp1,q);
  madd(temp1,hash,q);

  mmult(mykprime,temp1,s,q);

  printf("s is:\n");
  fprintUL(stdout,s,32);

  /* calculate w=sprime */
  mmult(qminus1,fminus1,temp1,p);
  msub(temp1,one,p);
  
  mexp(s,temp1,w,q);

  printf("w is:\n");
  fprintUL(stdout,w,32);

  /* calculate u1 */
  mmult(hash,w,u1,q);

  printf("u1 is:\n");
  fprintUL(stdout,u1,32);

  /* calculate u2 */
  mmult(r,w,u2,q);

  printf("u2 is:\n");
  fprintUL(stdout,u2,32);

  /* now calculate v */
  mexp(g,u1,temp1,p);
  mexp(y,u2,temp2,p);
  mmult(temp1,temp2,temp1,p);

  mmult(one,temp1,v,q);
                     
  printf("v is:\n");
  fprintUL(stdout,v,32);

  if (mcmp(r,v)==0)
    printf("v==r, Signature verifies!\n");
  else
    printf("v!=r, Signature does not verify!\n");

}
_______________________________________________________________________________
long.h used by both programs:
________________________________________________________________________________
typedef unsigned long UL;

int add(UL *a, UL *b, int c);
int sub(UL *a, UL *b, int c);
int shl(UL *a, int b);

int mcmp(UL *a, UL *b);
void madd(UL *a, UL *b, UL *P);
void msub(UL *a, UL *b, UL *P);
void mshl(UL *a, UL *P);
void mexp(UL *a, UL *b, UL *result, UL *P);
void mmult(UL *a, UL *b, UL *result, UL *P);
void zeroUL(UL *a, int size);

int lehman_prime(UL *p, UL *s);
int divides(UL *a, UL b);
void copyUL(UL *a, UL *b, int size);
________________________________________________________________________________
long.c used by both programs:
________________________________________________________________________________

/*=============================================================================
Assignment: Diffie-Hellman key exchange
Author:     David J. Burger
Language:   ANSI C running on UHUNIX2 (Solaris)

Class:      ICS 623
Instructor: Dr. Peterson
Due Date:   11/21/01
===============================================================================
File:         long.c

Description:  this file contains various long arithmetic functions.  The first
              functions in the file are those supplied by Dr. Peterson.
=============================================================================*/

#include "long.h"

/* primes used in lehman_prime */
UL samp_primes[][32] = { { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 313 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 383 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 491 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 503 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 617 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 809 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 829 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 911 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 947 },
                         { 0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 0,
                           0, 0, 0, 0, 0, 0, 0, 997 } };


/* This adds the 512-bit number that b points   */
/* to to the 512-bit number that a points to.   */
/* c is assumed to be 0 or 1, the carry in,     */
/* and is added to the sum. The carry out of    */
/* the highest-order word (1 or 0) is returned. */
int add(UL *a, UL *b, int c)
{
    UL t;
    t = a[15] + b[15];
    a[15] = t+c;
    c = t<b[15] || t==0xffffffff && c==1;
    t = a[14] + b[14];
    a[14] = t+c;
    c = t<b[14] || t==0xffffffff && c==1;
    t = a[13] + b[13];
    a[13] = t+c;
    c = t<b[13] || t==0xffffffff && c==1;
    t = a[12] + b[12];
    a[12] = t+c;
    c = t<b[12] || t==0xffffffff && c==1;
    t = a[11] + b[11];
    a[11] = t+c;
    c = t<b[11] || t==0xffffffff && c==1;
    t = a[10] + b[10];
    a[10] = t+c;
    c = t<b[10] || t==0xffffffff && c==1;
    t = a[9] + b[9];
    a[9] = t+c;
    c = t<b[9] || t==0xffffffff && c==1;
    t = a[8] + b[8];
    a[8] = t+c;
    c = t<b[8] || t==0xffffffff && c==1;
    t = a[7] + b[7];
    a[7] = t+c;
    c = t<b[7] || t==0xffffffff && c==1;
    t = a[6] + b[6];
    a[6] = t+c;
    c = t<b[6] || t==0xffffffff && c==1;
    t = a[5] + b[5];
    a[5] = t+c;
    c = t<b[5] || t==0xffffffff && c==1;
    t = a[4] + b[4];
    a[4] = t+c;
    c = t<b[4] || t==0xffffffff && c==1;
    t = a[3] + b[3];
    a[3] = t+c;
    c = t<b[3] || t==0xffffffff && c==1;
    t = a[2] + b[2];
    a[2] = t+c;
    c = t<b[2] || t==0xffffffff && c==1;
    t = a[1] + b[1];
    a[1] = t+c;
    c = t<b[1] || t==0xffffffff && c==1;
    t = a[0] + b[0];
    a[0] = t+c;
    c = t<b[0] || t==0xffffffff && c==1;
    return c;
}

/* This sutracts the 512-bit word that b points   */
/* to from the 512-bit number that a points to.   */
/* c (1 or 0) is subtracted from the result, and  */
/* if there is a borrow out of the high end, it   */
/* (1 or 0) is returned.                          */
int sub(UL *a, UL *c, int b1)
{
    int b2;
    b2 = a[15]<c[15] || a[15]==c[15] && b1==1;
    a[15] -= c[15]+b1;
    b1 = a[14]<c[14] || a[14]==c[14] && b2==1;
    a[14] -= c[14]+b2;
    b2 = a[13]<c[13] || a[13]==c[13] && b1==1;
    a[13] -= c[13]+b1;
    b1 = a[12]<c[12] || a[12]==c[12] && b2==1;
    a[12] -= c[12]+b2;
    b2 = a[11]<c[11] || a[11]==c[11] && b1==1;
    a[11] -= c[11]+b1;
    b1 = a[10]<c[10] || a[10]==c[10] && b2==1;
    a[10] -= c[10]+b2;
    b2 = a[9]<c[9] || a[9]==c[9] && b1==1;
    a[9] -= c[9]+b1;
    b1 = a[8]<c[8] || a[8]==c[8] && b2==1;
    a[8] -= c[8]+b2;
    b2 = a[7]<c[7] || a[7]==c[7] && b1==1;
    a[7] -= c[7]+b1;
    b1 = a[6]<c[6] || a[6]==c[6] && b2==1;
    a[6] -= c[6]+b2;
    b2 = a[5]<c[5] || a[5]==c[5] && b1==1;
    a[5] -= c[5]+b1;
    b1 = a[4]<c[4] || a[4]==c[4] && b2==1;
    a[4] -= c[4]+b2;
    b2 = a[3]<c[3] || a[3]==c[3] && b1==1;
    a[3] -= c[3]+b1;
    b1 = a[2]<c[2] || a[2]==c[2] && b2==1;
    a[2] -= c[2]+b2;
    b2 = a[1]<c[1] || a[1]==c[1] && b1==1;
    a[1] -= c[1]+b1;
    b1 = a[0]<c[0] || a[0]==c[0] && b2==1;
    a[0] -= c[0]+b2;
    return b1;
}

/* This shifts a left one bit. c (1 or 0)    */
/* is shifted into the lowest order position */
/* and the bit (1 or 0) shifted out of the   */
/* highest order position is returned.       */
int shl(UL *a, int c)
{
    int c1;
    c1 = a[0]>>31;
    a[0] = (a[0]<<1) | a[1]>>31;
    a[1] = (a[1]<<1) | a[2]>>31;
    a[2] = (a[2]<<1) | a[3]>>31;
    a[3] = (a[3]<<1) | a[4]>>31;
    a[4] = (a[4]<<1) | a[5]>>31;
    a[5] = (a[5]<<1) | a[6]>>31;
    a[6] = (a[6]<<1) | a[7]>>31;
    a[7] = (a[7]<<1) | a[8]>>31;
    a[8] = (a[8]<<1) | a[9]>>31;
    a[9] = (a[9]<<1) | a[10]>>31;
    a[10] = (a[10]<<1) | a[11]>>31;
    a[11] = (a[11]<<1) | a[12]>>31;
    a[12] = (a[12]<<1) | a[13]>>31;
    a[13] = (a[13]<<1) | a[14]>>31;
    a[14] = (a[14]<<1) | a[15]>>31;
    a[15] = (a[15]<<1) | c;
    return c1;
}

/* Here are several 1023-bit mod P functions: */

/* Return negative,if a<b, zero if */
/* a=b and positive if a>b.        */
int mcmp(UL *a, UL *b)
{
	int i;
	for(i = 0; i<32; i++) {
		if(a[i]>b[i]) return 1;
		if(a[i]<b[i]) return -1;
	}
	return 0;
}

/* add b to a */
void madd(UL *a, UL *b, UL *P)
{
	add(a, b, add(a+16, b+16, 0));
	if(mcmp(a, P)>=0) sub(a, P, sub(a+16, P+16, 0));
}

/* subtract b from a */
void msub(UL *a, UL *b, UL *P)
{
	if(sub(a, b, sub(a+16, b+16, 0))) 
		add(a, P, add(a+16, P+16, 0));
}

/* shift a left one bit  */
void mshl(UL *a, UL *P)
{
	shl(a, shl(a+16, 0));
	if(mcmp(a, P)>=0) sub(a, P, sub(a+16, P+16, 0));
}

/*=============================================================================
Function mmult

Purpose:  mutiply a by b mod P and put the result in result
          
Parameters:
          *a - first operator
          *b - second operator
          *result - where the result is placed
          *P - modulus
          
Returns:  nothing, result of multiplication is placed in result
=============================================================================*/
void mmult(UL *a, UL *b, UL *result, UL *P) {
  int i,j;
  UL mask;
  UL t[32];
  zeroUL(t,32);
  /* looping through the 32 words */
  for (i=0;i<32;i++) {
    mask = 0x80000000;
    /* looping through the 32 bits */
    for (j=0;j<32;j++) {
      mshl(t,P);
      if (b[i] & mask) madd(t,a,P);
      mask>>=1;
    }
  }

  /* answer is in t[], put in result */
  for (i=0;i<32;i++)
    result[i] = t[i];

}

/*=============================================================================
Function mexp

Purpose:  take a to the power b mod P and put result in result
          
Parameters:
          *a - base of exponentiation
          *b - exponent
          *result - where the result is placed
          *P - modulus
          
Returns:  nothing, result of exponentiation is placed in result
=============================================================================*/
void mexp(UL *a, UL *b, UL *result, UL *P) {
  int i,j;
  UL mask;
  UL t[32];
  zeroUL(t,32);
  t[31] = 1;
  /* looping through the 32 words */
  for (i=0;i<32;i++) {
    mask = 0x80000000;
    /* looping through the 32 bits */
    for (j=0;j<32;j++) {
      mmult(t,t,t,P);
      if (b[i] & mask) mmult(t,a,t,P);
      mask>>=1;
    }
  }

  /* answer is in t[], put in result */
  for (i=0;i<32;i++)
    result[i] = t[i];

}

/*=============================================================================
Function zeroUL

Purpose:  used to "zero out" the values in an unsigned long array
          
Parameters:
          *a - array to zero out
          size - number of values to zero out
          
Returns:  nothing, size values in a are set to 0
=============================================================================*/
void zeroUL(UL *a, int size) {
  while (--size>=0) a[size] = 0;
}

/* where p = 2s + 1, return 1 prime, 0 otherwise */
int lehman_prime(UL *p, UL *s) {
  UL small_primes[] = { 3,5,7,11,13,17,23,31 };
  UL result[32],one[32],negone[32];
  int i,numone=0;

  for (i=0;i<8;i++)
    if (divides(p,small_primes[i])) return 0;

  zeroUL(one,32);
  one[31] = 1;
  copyUL(p,negone,32);
  sub(negone,one,sub(negone+16,one+16,0));

  for (i=0;i<10;i++) {
    mexp(samp_primes[i],s,result,p);
    if (mcmp(result,one)==0) numone++;
    if (!(mcmp(result,one)==0 || mcmp(result,negone)==0)) return 0;
  }
  return numone!=10;
}

/*=============================================================================
Function divides

Purpose:  used to determine if a 32 bit unsigned long will divide a 1024 bit
          unsigned long evenly
          
Parameters:
          *a - dividend array holding 32 UL values making a 1024 bit number
          b - divisor
          
Returns:  1 if divisible, 0 otherwise
=============================================================================*/
int divides(UL *a, UL b) {
  int i;
  UL t[33];
  t[0] = 0;
  copyUL(a,t+1,32);
  for (i=0;i<1024;i++) {
    if (t[0]>=b) t[0]-=b;
    if (t[32] & 0x80000000)
      shl(t,shl(t+16,1));
    else
      shl(t,shl(t+16,0));
    t[32]<<=1;
  }
  if (t[0]>=b) t[0]-=b;
  return t[0]==0;
}

/*=============================================================================
Function copyUL

Purpose:  copies size unsigned long values from a to b
          
Parameters:
          *a - array containing unsigned longs to copy
          *b - array to copy to
          size - number of unsigned longs to copy from a to b
          
Returns:  nothing, size values are copied from a to b
=============================================================================*/
void copyUL(UL *a, UL *b, int size) {
  while (--size>=0) b[size] = a[size];
}
________________________________________________________________________________
sha1.h used by both programs:
________________________________________________________________________________

/*=============================================================================
Assignment:  Implementation of secure hash algorithm (SHA-1).
             
Author:      David J. Burger
Language:    ANSI C running on UHUNIX2 (Solaris)
Compile:     by running "make" with supplied makefile

Execute:     ./shatest filename

Class:       ICS 623
Instructor:  Dr. Peterson
Due Date:    09/17/01
=============================================================================*/
struct hash {
    unsigned long H0;
    unsigned long H1;
    unsigned long H2;
    unsigned long H3;
    unsigned long H4;
    unsigned long sizeHi;
    unsigned long sizeLo;
};

void sha1File(FILE *fp, struct hash *h);
void sha1Mem(char *buff, int len, struct hash *h);
________________________________________________________________________________
sha1.c used by both programs:
________________________________________________________________________________

/*=============================================================================
Assignment:  Implementation of secure hash algorithm (SHA-1).
             
Author:      David J. Burger
Language:    ANSI C running on UHUNIX2 (Solaris)
Compile:     by running "make" with supplied makefile

Execute:     ./shatest filename

Class:       ICS 623
Instructor:  Dr. Peterson
Due Date:    09/17/01
===============================================================================
File:         sha1.c

Description:  This file contains the algorithms to compute SHA-1 values.
              
Functions:    void sha1File(FILE *fp, struct hash *h) - computes the hash value
                  for the file of passed in FILE *fp.
                  
              void sha1Mem(char *buff, int len, struct hash *h) - computes the
                  hash value for the char *buff of length len.
=============================================================================*/
#include <stdio.h>
#include "sha1.h"

unsigned long circShiftLeft(unsigned long l, int bits);

static void sha1();

/* sha-1 variables */
static unsigned long A, B, C, D, E;
static unsigned long H0, H1, H2, H3, H4;
static unsigned long W[80], TEMP;

static unsigned long buffer[16]; /* buffer for reading from the file */

/*=============================================================================
Function sha1File

Purpose:  This function computes the hash value for the passed in file.
          
Parameters:
    FILE *fp (IN) - a FILE * to the file to deterine the hash value of
    struct hash *h (OUT) - a structure to return the hash value in

Returns:  struct hash *h contains the hash value
=============================================================================*/
void sha1File(FILE *fp, struct hash *h) {
    char *p; /* char pointer for working with the buffer */
    int bytesRead; /* the number of bytes read on fread call */
    unsigned long fileBitsLo = 0; /* keeps track of the file size */
    unsigned long fileBitsHi = 0;
    unsigned long fileBitsBefore;

    H0 = 0x67452301; /* init to SHA-1 initial values */
    H1 = 0xEFCDAB89;
    H2 = 0x98BADCFE;
    H3 = 0x10325476;
    H4 = 0xC3D2E1F0;

    while (!feof(fp)) {
        bytesRead = fread(buffer,1,sizeof(buffer),fp);
        fileBitsBefore = fileBitsLo;
        fileBitsLo+=bytesRead*8;
        if (fileBitsBefore>fileBitsLo) fileBitsHi++; /* carry */
        if (bytesRead==sizeof(buffer)) {
            sha1(); /* computing sha1 on buffer block */
        } else { /* we have a partial block */
            p = (char *)buffer;
            p[bytesRead] = 0x80; /* put the 1 bit after last byte read */
            memset(p+bytesRead+1,0,sizeof(buffer)-bytesRead-1); /* zero out  */
            if (sizeof(buffer)-bytesRead-1<8) { /* figure out if room for sze*/
                sha1(); /* no room for size in this block compute sha1()     */
                /* now make a new last block with the size */
                memset(p,0,sizeof(buffer));
                buffer[14] = fileBitsHi;
                h->sizeHi = fileBitsHi;
                buffer[15] = fileBitsLo;
                h->sizeLo = fileBitsLo;
                sha1(); /* compute sha1() for this last block */
            } else { /* room for size in the block */
                buffer[14] = fileBitsHi;
                h->sizeHi = fileBitsHi;
                buffer[15] = fileBitsLo; /* put the size in */
                h->sizeLo = fileBitsLo;
                sha1(); /* compute sha1() for this last block */
            }
        }
    }

    h->H0 = H0;
    h->H1 = H1;
    h->H2 = H2;
    h->H3 = H3;
    h->H4 = H4;

}

/*=============================================================================
Function sha1Mem

Purpose:  This function computes the hash value for the passed in buffer.
          
Parameters:
    char *buff (IN) - a char * to the buffer to determine the hash of
    int len (IN) - the length of the buffer
    struct hash *h (OUT) - a structure to return the hash value in

Returns:  struct hash *h contains the hash value
=============================================================================*/
void sha1Mem(char *buff, int len, struct hash *h) {
    char *p; /* char pointer for working with the buffer */
    int buffLeft = len;
    unsigned long bitsLo = 0; /* keeps track of the file size */
    unsigned long bitsHi = 0;
    unsigned long bitsBefore;

    H0 = 0x67452301; /* init to SHA-1 initial values */
    H1 = 0xEFCDAB89;
    H2 = 0x98BADCFE;
    H3 = 0x10325476;
    H4 = 0xC3D2E1F0;

    while (buffLeft>=sizeof(buffer)) {      /* loop through the buffer */
        memcpy(buffer,buff,sizeof(buffer)); /* a block at a time       */
        buff+=sizeof(buffer);               /* tracking file size */
        buffLeft-=sizeof(buffer);
        bitsBefore = bitsLo;
        bitsLo+=sizeof(buffer)*8;
        if (bitsBefore>bitsLo) bitsHi++; /* carry */
        sha1(); /* compute sha1() for this block */
    }

    /* we now have only a partial block left */
    memcpy(buffer,buff,buffLeft); /* copy partial block */
    bitsBefore = bitsLo;          /* tracking file size */
    bitsLo+=buffLeft*8;
    if (bitsBefore>bitsLo) bitsHi++;
    p = (char *)buffer;
    p[buffLeft] = 0x80; /* set the 1 bit */
    memset(p+buffLeft+1,0,sizeof(buffer)-buffLeft-1); /* zero out rest */
    if (sizeof(buffer)-buffLeft-1<8) { /* figure out if room for size */
        sha1(); /* no room for size in this block, compute sha1() for buffer */
        /* now make a new last block with the size */
        memset(p,0,sizeof(buffer));
        buffer[14] = bitsHi;
        h->sizeHi = bitsHi;
        buffer[15] = bitsLo;
        h->sizeLo = bitsLo;
        sha1(); /* compute sha1() for this last block */
    } else { /* room for size in the block */
        buffer[14] = bitsHi;
        h->sizeHi = bitsHi;
        buffer[15] = bitsLo; /* put the size in */
        h->sizeLo = bitsLo;
        sha1(); /* compute sha1() for this last block */
    }

    h->H0 = H0;
    h->H1 = H1;
    h->H2 = H2;
    h->H3 = H3;
    h->H4 = H4;

}

/*=============================================================================
Function circShiftLeft

Purpose:  This function does a left circular shift on unsigned long values
          
Parameters:
    unsigned long l (IN) - value to shift
    int bits (IN) - # of places to shift

Returns:  the value of unsigned long l shifted left int bits
=============================================================================*/
unsigned long circShiftLeft(unsigned long l, int bits) {
  return (l << bits) | (l >> 32 - bits);
}

/*=============================================================================
Function sha1

Purpose:  This function performs a sinle "cycle" of the sha-1 algorithm.  Code
          designed from specifications from the:
          American National Standard for Financial Services
          Public Key Cryptography for the Financial Services Industry:
          Part 2:  The Secure Hash Algorithm (SHA-1)
          (Revision of X9.30:2-1993)
          
Parameters:
    none
Returns:  nothing, however it adjusts the static variables to the proper values
          for the sha-1 computation
=============================================================================*/
void sha1() {
  int i,t;

  for (i=0;i<16;i++)
    W[i] = buffer[i];

  for (t=16;t<80;t++)
    W[t] = circShiftLeft(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16],1);

  A = H0;
  B = H1;
  C = H2;
  D = H3;
  E = H4;

  for (t=0;t<20;t++) {
    TEMP = circShiftLeft(A,5) + ((B&C)|(~B&D)) + E + W[t] + 0x5A827999;
    E = D;
    D = C;
    C = circShiftLeft(B,30);
    B = A;
    A = TEMP;
  }

  for (t=20;t<40;t++) {
    TEMP = circShiftLeft(A,5) + (B^C^D) + E + W[t] + 0x6ED9EBA1;
    E = D;
    D = C;
    C = circShiftLeft(B,30);
    B = A;
    A = TEMP;
  }

  for (t=40;t<60;t++) {
    TEMP = circShiftLeft(A,5) + ((B&C)|(B&D)|(C&D)) + E + W[t] + 0x8F1BBCDC;
    E = D;
    D = C;
    C = circShiftLeft(B,30);
    B = A;
    A = TEMP;
  }

  for (t=60;t<80;t++) {
    TEMP = circShiftLeft(A,5) + (B^C^D) + E + W[t] + 0xCA62C1D6;
    E = D;
    D = C;
    C = circShiftLeft(B,30);
    B = A;
    A = TEMP;
  }

  H0+=A;
  H1+=B;
  H2+=C;
  H3+=D;
  H4+=E;

}

