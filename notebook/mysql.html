<!--
Content-type: Preventing XSRF in IE.

-->
<html><head><link type="text/css" rel="stylesheet" href="/notebook/resources/1553808490-public_css.css">
<title>mysql</title></head>
<body bgcolor="#FFFFFF" onload=""><link type="text/css" rel="stylesheet" href="/notebook/resources/3158938506-staticpages_css.css">
<table align="center" border="0" cellpadding="5" cellspacing="0" width="100%"><tr valign="middle"><td width="1%"><a href="/notebook/"><img src="/notebook/images/en_notebook_150x55.png" align="left" border="0" height="55" width="150" alt="Google Notebook"></a></td>
<td><table style="margin-bottom: 5px;" align="center" bgcolor="#c3d9ff" border="0" cellpadding="0" cellspacing="0" width="100%" dir="ltr"><tr><td class="bubble tl" align="left" valign="top"><img src="/notebook/images/corner_tl.gif" class="c" alt=""></td>
<td class="bubble1" rowspan="2" style="padding: 3px 0pt; font-family: arial; text-align: left; font-weight: bold; font-size: 100%;">mysql</td>
<td class="bubble tr" align="right" valign="top"><img src="/notebook/images/corner_tr.gif" class="c" alt=""></td></tr>
<tr><td class="bubble bl" align="left" valign="bottom"><img src="/notebook/images/corner_bl.gif" class="c" alt=""></td>
<td class="bubble br" align="right" valign="bottom"><img src="/notebook/images/corner_br.gif" class="c" alt=""></td></tr></table></td></tr></table>
<br>
<div id="pubContent"><div id="pubHeader"><div id="pubHeaderSub">Last edited  March 29, 2007 
<br></div></div>

<a name="NDR-OIgoQ4e_6krki"></a>
<div class="PubNote">
<div class="PubNoteContentArea">Simple join query to get the list of resources that a particular resource is linked to.  First the schema:<br><br> <font face="courier new,monospace">mysql&gt; describe resources;<br>+-------+--------------+------+-----+---------+----------------+<br>| Field | Type         | Null | Key | Default | Extra          |<br>+-------+--------------+------+-----+---------+----------------+<br>| id    | int(11)      | NO   | PRI | NULL    | auto_increment | <br>| name  | varchar(255) | NO   |     |         |                | <br>+-------+--------------+------+-----+---------+----------------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; describe resource_links;<br>+--------------------+---------+------+-----+---------+----------------+<br>| Field              | Type    | Null | Key | Default | Extra          |<br>+--------------------+---------+------+-----+---------+----------------+<br>| id                 | int(11) | NO   | PRI | NULL    | auto_increment | <br>| resource_id        | int(11) | NO   |     |         |                | <br>| linked_resource_id | int(11) | NO   |     |         |                | <br>+--------------------+---------+------+-----+---------+----------------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt;<br><font face="arial,sans-serif"><br>The query is simple:<br><br><font face="courier new,monospace">SELECT r.* FROM<br>  resources r INNER JOIN resource_links rl ON r.id = rl.linked_resource_id<br>  WHERE rl.resource_id = ?</font><br><br>In rails find or paginate this has to be done with the options syntax and the needed options are likely this (remember this is in the context of a Resource.find thus why that table name is available in the :join):<br><br><font face="courier new,monospace">:join =&gt; &#39;INNER JOIN resources_links ON resources.id = resources_links.linked_resource_id&#39;,<br>:condition =&gt; [&#39;resources.resource_id = ?&#39;, params[:id]]</font><br><br>Of course with a find_by_sql you can just crank out the full query.<br></font></font></div>
</div> <a name="NDRqeIgoQ6LD9kbki"></a>
<div class="PubNote">
<div class="PubNoteContentArea"> The table resources has a self linking resource_links table that allows two resources to be linked with extra information about the linkage.  The basic setup is this:<br><br><font face="courier new,monospace">mysql&gt; describe resources;<br>+-------+--------------+------+-----+---------+----------------+<br>| Field | Type         | Null | Key | Default | Extra          |<br>+-------+--------------+------+-----+---------+----------------+<br>| id    | int(11)      | NO   | PRI | NULL    | auto_increment | <br>| name  | varchar(255) | NO   |     |         |                | <br>+-------+--------------+------+-----+---------+----------------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; describe resource_links;<br>+--------------------+---------+------+-----+---------+----------------+<br>| Field              | Type    | Null | Key | Default | Extra          |<br>+--------------------+---------+------+-----+---------+----------------+<br>| id                 | int(11) | NO   | PRI | NULL    | auto_increment | <br>| resource_id        | int(11) | NO   |     |         |                | <br>| linked_resource_id | int(11) | NO   |     |         |                | <br>+--------------------+---------+------+-----+---------+----------------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; </font><br><br>Now in orde<font face="arial,sans-serif">r to select the resources for which a particular resource DOES NOT have a linkage, the following s</font>imple sub-select query does the trick:<br><br><font face="courier new,monospace">SELECT r.* FROM resources r WHERE <a href="http://r.id/">r.id</a> NOT IN (<br>  SELECT linked_resource_id FROM resource_links WHERE resource_id = ?<br>);</font><br><br>or to even eliminate the record itself from the list:<br><br><font face="courier new,monospace">SELECT r.* FROM resources r WHERE <a href="http://r.id/">r.id</a> NOT IN (<br>  SELECT linked_resource_id FROM resource_links WHERE resource_id = ?<br>  UNION SELECT ?<br>);</font><br><br>With the same id used twice.  This can also be done purely with joins, which may be more efficient but I don&#39;t have a large enough data set to test this on.  The join technique is like this:<br><br><font face="courier new,monospace">SELECT r1.* FROM resources r1 LEFT JOIN (resources r2 INNER JOIN<br>resource_links rl ON <a href="http://r2.id/">r2.id</a> = rl.resource_id AND rl.resource_id = ?) ON<br><a href="http://r1.id/">r1.id</a> = rl.linked_resource_id WHERE <a href="http://r2.id/">r2.id</a> IS NULL;<br><font face="arial,sans-serif"><br>And if you want to eliminate the resource itself as one of the results of resources then you can just add the condition:<br><br></font></font><font face="courier new,monospace">SELECT r1.* FROM resources r1 LEFT JOIN (resources r2 INNER JOIN<br>
resource_links rl ON <a href="http://r2.id/">r2.id</a> = rl.resource_id AND rl.resource_id = ?) ON<br>
<a href="http://r1.id/">r1.id</a> = rl.linked_resource_id WHERE <a href="http://r2.id/">r2.id</a> IS NULL AND r1.id &lt;&gt; ?;</font><br></div>
</div> <a name="NDQGmSwoQuLndkrki"></a>
<div class="PubNote">
<div class="PubNoteContentArea">Aggregate query for pulling in the unique resource categories used for a particular unit along with a count  of how many times each is used.  In rails can be used in a ResourceCategory.find_by_sql and the return result will be ActiveRecord model objects with an extra field for the aggregate.<br><br><font face="courier new,monospace">SELECT rc.*, COUNT(<a href="http://rc.id/">rc.id</a>) AS count FROM units u<br>  INNER JOIN unit_resources ur ON <a href="http://u.id/">u.id</a> = ur.unit_id<br>  INNER JOIN resources r ON ur.resource_id = <a href="http://r.id/">r.id</a><br>  INNER JOIN resource_categories rc ON r.resource_category_id = <a href="http://rc.id/">rc.id</a><br>  WHERE <a href="http://u.id/">u.id</a> = ?<br>  GROUP BY <a href="http://rc.id/">rc.id</a><br>  ORDER BY count DESC;</font><br></div>
</div> <a name="NDQ3RIgoQmJK8274i"></a>
<div class="PubNote">
<div class="PubNoteContentArea">attribute_groups can be assigned to resources in a join table called resources_attribute_groups.  When attempting to link new attribute groups to a resource, we want to only display those that aren&#39;t already linked.  The SQL for selecting those not already applied to the resource is:<br><br>SELECT ag1.* FROM attribute_groups ag1 LEFT JOIN (attribute_groups ag2<br>    INNER JOIN resources_attribute_groups rag ON <a href="http://ag2.id/">ag2.id</a> = rag.attribute_group_id AND rag.resource_id = ?)<br>    ON <a href="http://ag1.id/">ag1.id</a> = rag.attribute_group_id WHERE <a href="http://ag2.id/">ag2.id</a> IS NULL;<br> <br><br>In rails, the finder code for a paginator looks like this:<br><br>   @attribute_group_pages, @attribute_groups = paginate(<br>       :attribute_groups,<br>       :per_page =&gt; 20,<br>       :select =&gt; &#39;ag1.*&#39;,<br>       :joins =&gt; ActiveRecord::Base.send(:sanitize_sql, [&#39;ag1 LEFT JOIN (attribute_groups ag2 INNER JOIN<br>                      resources_attribute_groups rag ON <a href="http://ag2.id/">ag2.id</a> = rag.attribute_group_id AND<br>                      rag.resource_id = ?) ON attribute_groups.id =<br>                      rag.attribute_group_id&#39;, params[:id]])<br>       :conditions =&gt; &#39;rag.attribute_group_id IS NULL&#39;,<br>       :order =&gt; &#39;ag1.name&#39;<br>   )<br><br>Notice that ActiveRecord does not provide for binding parameters in the joins clause and thus I&#39;m forced to do it myself....and....you have to use a trick to be able to call the protected class method of ActiveRecord::Base, sanitize_sql.<br></div>
</div> <a name="NDSS8IgoQm-ze8Loi"></a>
<div class="PubNote">
<div class="PubNoteContentArea">After truncating as above, can put data local from remote server as follows.  Note that this grabs only data, as the -t options prevents it from creating the structure as well.  Without the -t I suppose you could do the same thing and start with an empty sps_development database:<br><br>$ ssh tsunami.camberhawaii.org &#39;mysqldump -usps -psps0509 -t sps_development&#39; | mysql -usps -psps0509 sps_development</div>
</div> <a name="NDQGkIwoQxJD24eAi"></a>
<div class="PubNote">
<div class="PubNoteContentArea">Recently I had a ticket to return only the lastest  QuizResult per user for a particular Quiz.  That is a User may have taken a quiz several time but in the status report we only want to see the latest quiz result for each of these users.  You can grab this information in an SQL statement like this:<br><br>(1)      SELECT qr.*, MAX(qr.completed_at) FROM quiz_results qr<br>            JOIN users u ON qr.user_id = <a href="http://u.id/">u.id</a><br>            WHERE qr.quiz_id = #{id}<br>            GROUP BY qr.user_id<br>            ORDER BY u.last_name, u.first_name;<br><br>and if you are only concerned about getting the ids of those QuizResults you can do something like this:<br><br>(2)    SELECT <a href="http://qr.id/">qr.id</a>, MAX(qr.completed_at) FROM quiz_results qr<br>          JOIN users u ON qr.user_id = <a href="http://u.id/">u.id</a><br>          WHERE qr.quiz_id = #{id}<br>          GROUP BY qr.user_id<br>          ORDER BY <a href="http://qr.id/">qr.id</a>;<br><br>Now from the rails perspective this type of query becomes complicated because of the fact that when I do this query I want to include User with the QuizResult to avoid, for example, an extra query every time I do quiz_result.user.full_name with the result of the query.  That means I have to spell out all the fields I want to grab to populate a QuizResult and a User in the query so that rails can do the :include correctly, in addition to injecting the MAX(quiz_results.completed_at) for the :group.  This would look something like this:<br><br>  has_many :latest_quiz_results, :class_name =&gt; &#39;QuizResult&#39;, :include =&gt; :user,<br>           :select =&gt; &#39;MAX(quiz_results.completed_at), quiz_results.`id` AS t0_r0, quiz_results.`user_id` AS t0_r1, quiz_results.`quiz_id` AS t0_r2, quiz_results.`created_at` AS t0_r3, quiz_results.`completed_at` AS t0_r4, quiz_results.`number_of_questions` AS t0_r5, quiz_results.`number_correct` AS t0_r6, quiz_results.`passing_grade` AS t0_r7, users.`id` AS t1_r0, users.`login` AS t1_r1, users.`email` AS t1_r2, users.`crypted_password` AS t1_r3, users.`salt` AS t1_r4, users.`created_at` AS t1_r5, users.`updated_at` AS t1_r6, users.`remember_token` AS t1_r7, users.`remember_token_expires_at` AS t1_r8, users.`first_name` AS t1_r9, users.`last_name` AS t1_r10, users.`secondary_email` AS t1_r11, users.`phone` AS t1_r12, users.`secondary_phone` AS t1_r13, users.`password_reset_key` AS t1_r14, users.`password_reset_key_issued_at` AS t1_r15, users.`address1` AS t1_r16, users.`address2` AS t1_r17, users.`city` AS t1_r18, users.`state` AS t1_r19, users.`country` AS t1_r20, users.`zip_code` AS t1_r21&#39;,<br>           :group =&gt; &#39;<a href="http://users.id/">users.id</a>&#39;<br><br>Now there are a couple of problems with this.  First, I had to spell out all the field names to put this query together, which is quite fragile to changes in the schema (although I could probably produce this automatically using a SELECT FIELDS query.  Second, if I want to feed a paginate call I am going to have to rewrite all of this code into the call, not pretty.<br><br>So an alternate strategy is to write a method that returns the latest QuizResult ids in an array, which then can be used to feed queries that use :where =&gt; &quot;quiz_results.id IN (#{those returned ids joined together})&quot;.  This makes it so that you can feed the already defined has_many :quiz_results with the where clause.  You can also use the :where in a paginate call to set it up much more simply.  The query to return those QuizResult ids looks like this:<br><br>  def latest_quiz_results_ids(include_user_ids = nil)<br>    user_id_clause = &#39;&#39;<br>    if include_user_ids<br>       return [] if include_user_ids.empty?<br>        include_user_ids.map! {|id| id.to_i}<br>        user_id_clause = &#39; AND qr.user_id IN (&#39; + include_user_ids.join(&#39;,&#39;) + &#39;)&#39;<br>    end<br>    sql = &lt;&lt;-EOSQL<br>        SELECT <a href="http://qr.id/">qr.id</a>, MAX(qr.completed_at) FROM quiz_results qr<br>          JOIN users u ON qr.user_id = <a href="http://u.id/">u.id</a><br>          WHERE qr.quiz_id = #{id}#{user_id_clause}<br>          GROUP BY qr.user_id<br>          ORDER BY <a href="http://qr.id/">qr.id</a>;<br>    EOSQL<br>    ids = []<br>    connection.execute(sql).each {|qr| ids.push(qr[0].to_i)}<br>    ids<br>  end<br><br>This would be used in a query like this:<br><br>      @quiz_results = @quiz.quiz_results.find(:all,<br>                                              :conditions =&gt; &#39;quiz_results.id IN (&#39; + @quiz.latest_quiz_result_ids.join(&#39;,&#39;) + &#39;)&#39;,<br>                                              :order =&gt; &#39;users.last_name, users.first_name&#39;)<br></div>
</div></div></body></html>